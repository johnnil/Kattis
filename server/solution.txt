My solution wastes quite a bit of memory space by drawing a timeline at full resolution. However, the end result is (hopefully) easy to follow. For each instruction, I mark its start time with 1 and end time with -1. When reading the sequence of timestamps in the timeline, this allows "the printhead" (or zipper) to count the number of instructions running at each timestamp. By keeping track of the maximum while going through the timeline we have the answer at the end by ceiling-dividing by the number of instructions each server can run concurrently.